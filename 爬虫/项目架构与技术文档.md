# 电力市场数据自动化采集系统 - 技术文档

## 📋 项目概述

这是一个基于 **Chrome Extension Manifest V3** 架构开发的电力市场数据自动化采集系统，支持安徽、北京、山东、江苏四省电力交易数据的智能化抓取与存储。系统通过 RPA（机器人流程自动化）技术实现页面自动操作、数据拦截、解析和存储的全流程自动化。

### 核心价值
- **多省份适配**：支持4个省份，每个省份3种运行模式（开发/生产自动/生产手动），共计12种构建配置
- **智能调度**：基于时间点的智能任务调度，支持高频采集和常规采集
- **数据完整性**：通过录入状态接口查询，确保数据不重不漏
- **高可靠性**：多重异常处理、重试机制、状态恢复机制

---

## 🏗️ 系统架构

### 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    Chrome Extension Layer                    │
├─────────────┬─────────────┬─────────────┬──────────────────┤
│   Popup     │   Options   │   Content   │    Background     │
│   (控制面板)  │   (配置页)   │  Script     │  Service Worker  │
│             │             │  (核心逻辑)   │   (消息中心)      │
└─────────────┴─────────────┴─────────────┴──────────────────┘
                                │
                    ┌───────────┴────────────┐
                    │                        │
            ┌───────▼────────┐      ┌───────▼────────┐
            │  Injected.js   │      │  DOM Watcher   │
            │  (请求拦截)     │      │  (渲染监听)     │
            └────────────────┘      └────────────────┘
                    │                        │
            ┌───────▼────────────────────────▼────────┐
            │         Target Web Application          │
            │    (各省电力交易市场信息披露系统)         │
            └──────────────────────────────────────────┘
                                │
                    ┌───────────┴────────────┐
                    │                        │
            ┌───────▼────────┐      ┌───────▼────────┐
            │  Python Server │      │  Data Storage  │
            │  (验证码识别)   │      │  (大数据平台)   │
            └────────────────┘      └────────────────┘
```

### 技术栈

**前端核心**
- **TypeScript 5.2+**：类型安全的代码开发
- **Vue 3.3+**：组合式 API，响应式UI组件
- **Vite 5.0**：快速构建与热更新
- **Element Plus 2.6+**：企业级UI组件库
- **WebExtension Polyfill**：跨浏览器兼容

**工具库**
- **Lodash**：函数式编程工具
- **Day.js**：轻量级日期处理
- **node-html-parser**：HTML解析
- **Crypto-js**：加密解密

**后端辅助**
- **Python 3.9 + Flask**：验证码识别API服务
- **OpenCV**：图像处理（滑块验证码距离计算）
- **ddddocr**：OCR识别

---

## 🎯 核心功能模块

### 1. 多环境配置系统

**文件位置**: `config/systems.ts`, `src/manifest.ts`

**功能特点**：
- 支持 4 省 × 3 模式 = 12 种构建配置
- 动态 Manifest 生成（根据环境变量自动配置权限、图标、名称）
- 环境隔离（开发/生产数据互不干扰）

```typescript
// 构建命令示例
npm run devAH    // 安徽开发环境
npm run prodAH   // 安徽生产自动模式
npm run prodAHH  // 安徽生产手动模式
```

**技术难点**：
- Manifest V3 动态配置（需要在构建时生成，不能运行时修改）
- 多省份URL匹配规则管理
- Content Script 注入时机控制

---

### 2. 自动化控制引擎

**文件位置**: `src/entries/contentScript/informationDisclosure/autoClick/`

#### 2.1 ActionEntrance（动作入口控制器）

**核心职责**：
- 任务调度与编排
- 数据项队列管理（AsyncQueue）
- 时间点匹配与过滤
- 录入状态查询与数据去重

**技术亮点**：
```typescript
// 异步队列遍历（ES2018 异步迭代器）
for await (const dataItemInfo of this.dataQueue) {
  await this.getOneItemDataController(dataItemInfo)
}
```

**智能调度逻辑**：
1. 根据当前时间点（15分钟粒度）过滤待爬取数据项
2. 调用后端接口查询数据录入状态
3. 对比配置与实际状态，生成待爬取列表
4. 加入异步队列，按序执行

**状态判断流程**：
```
配置数据项 → 时间点匹配 → 录入状态查询 → 日期差异计算 → 
未录入日期筛选 → 队列加入 → 按序爬取
```

#### 2.2 LoopController（循环控制器）

**设计模式**：单例模式

**状态管理**：
- `running`：正常运行
- `paused`：暂停（可恢复）
- `stopped`：停止（不可恢复）

**应用场景**：
- 用户手动暂停/恢复爬取
- 异常情况下的流程中断
- 调试模式下的单步执行

#### 2.3 SetDynamicLoop（动态循环设置）

**功能**：根据数据项配置，动态生成操作序列

**支持的操作类型**：
- `date`：日期选择器
- `select`：下拉框选择
- `multipleSelect`：多选框
- `tree`：树形菜单
- `tab`：标签页切换
- `page`：分页翻页
- `queryBtn`：查询按钮点击

**递归循环逻辑**：
```typescript
// 示例：三层循环（日期 × 选项 × 分页）
values: [
  { type: ['T-1', 'T', 'T+1'] },           // 外层循环：3个日期
  { type: 'select', values: ['A', 'B'] },  // 中层循环：2个选项
  { type: 'page', values: '5' }            // 内层循环：5页数据
]
// 总共执行：3 × 2 × 5 = 30 次数据抓取
```

---

### 3. DOM 操作与监听系统

#### 3.1 DomRenderWatcher（DOM渲染观察器）

**文件位置**: `src/entries/contentScript/utils/DomRenderWatcher.ts`

**核心技术**：**MutationObserver API**

**功能**：
- 监听DOM变化（节点增删、属性修改）
- 等待异步渲染完成
- 防止操作时机过早导致失败

**实现原理**：
```typescript
// 监听DOM稳定（连续100ms无变化视为渲染完成）
const observer = new MutationObserver(() => {
  clearTimeout(timer)
  timer = setTimeout(resolve, 100)
})
observer.observe(document.body, {
  childList: true,
  subtree: true,
  attributes: true
})
```

#### 3.2 SetTreeRecursively（树形菜单递归点击）

**挑战**：
- 多级菜单需要逐层展开
- 菜单项可能延迟加载
- 点击后需等待页面跳转

**解决方案**：
```typescript
// 递归查找并点击菜单项
async start() {
  for (const level of this.treeLevels) {
    await this.findAndClick(level)
    await new DomRenderWatcher().watch()  // 等待渲染
    await promiseTimeout(500)              // 额外延迟
  }
}
```

---

### 4. 数据拦截与解析

#### 4.1 InterceptRequest（请求拦截器）

**文件位置**: `src/entries/contentScript/informationDisclosure/autoClick/InterceptRequest.ts`

**技术方案**：**Injected Script + 自定义事件**

**流程**：
1. **注入脚本**（injected.js）重写 `fetch` 和 `XMLHttpRequest`
2. **拦截响应**数据，通过 `CustomEvent` 发送到 Content Script
3. **Content Script** 接收事件，校验数据后发送到 Background
4. **Background** 调用后端接口存储数据

**关键代码**：
```javascript
// injected.js：拦截 fetch
const originalFetch = window.fetch
window.fetch = function(...args) {
  return originalFetch.apply(this, args).then(response => {
    response.clone().text().then(data => {
      window.dispatchEvent(new CustomEvent('intercept-fetch-xhr', {
        detail: { url: args[0], data }
      }))
    })
    return response
  })
}
```

**校验机制**：
- URL匹配校验（防止误拦截）
- 查询参数校验（确保数据对应性）
- 日期/选项值校验（防止数据错位）

#### 4.2 TableParser（表格解析器）

**文件位置**: `src/entries/contentScript/informationDisclosure/autoClick/TableParser.ts`

**核心难点**：**合并单元格处理**

**算法思路**：
1. 维护 `spanMap`（记录哪些单元格被合并占用）
2. 遍历每行时，跳过被占用的列
3. 解析 `rowspan` 和 `colspan` 属性，标记后续占用

**示例**：
```html
<table>
  <tr>
    <td rowspan="2">A</td>
    <td>B</td>
  </tr>
  <tr>
    <td>C</td>
  </tr>
</table>

解析结果：
[
  ['A', 'B'],
  ['A', 'C']  // 第二行第一列由第一行合并
]
```

**代码实现**：
```typescript
private markMergedCells(row: number, col: number, rowspan: number, colspan: number): void {
  for (let i = 0; i < rowspan; i++) {
    for (let j = 0; j < colspan; j++) {
      if (i === 0 && j === 0) continue  // 跳过起始单元格
      this.spanMap.set(`${row + i},${col + j}`, true)
    }
  }
}
```

---

### 5. 消息通信系统

**架构**: `Content Script ↔ Background ↔ Backend Server`

#### 5.1 Messenger（消息桥接器）

**文件位置**: `src/utils/Messenger.ts`

**特点**：
- 基于 `chrome.runtime.Port` 长连接
- 支持异步请求/响应模式
- 心跳机制（防止连接断开）
- 消息 ID 匹配（并发请求隔离）

**异步消息示例**：
```typescript
// Content Script
const result = await MsgFromToBackground
  .getInstance()
  .sendAsyncMsgToBackground({ 
    type: 'checkStatus', 
    payload: paramsList 
  })

// Background
BackgroundMsgHandler.handleMsg(message, portName)
  .then(response => port.postMessage(response))
```

#### 5.2 跨域通信方案

**挑战**：Content Script 受到 CORS 限制

**解决方案**：
1. **Content → Background**：通过 `chrome.runtime` API
2. **Background → Backend**：通过 `fetch`（无 CORS 限制）
3. **Backend → Storage**：直接存储或调用大数据平台接口

---

### 6. 省份配置系统

**文件位置**: `src/entries/contentScript/informationDisclosure/dataInfoConfig/`

**结构**：
```
dataInfoConfig/
├── AnHui/           # 安徽省配置
│   ├── index.ts
│   ├── tabs.ts
│   ├── snxhShiChangYunXing.ts  # 市场运行
│   ├── snxhShiChangJieSuan.ts  # 市场结算
│   └── ...
├── BeiJing/         # 北京省配置
├── ShanDong/        # 山东省配置
├── JiangSu/         # 江苏省配置
└── index.ts         # 统一导出
```

**配置示例**：
```typescript
{
  code: 'kbeTlKpLpnBtpEmbK6w1b...',  // 数据项唯一标识
  tab: '省内现货信息',
  saveType: 'bigData',               // 存储类型
  menuLevels: [                      // 菜单层级
    '省内现货市场',
    '市场结算信息',
    '结算总体情况及分类构成情况（日）'
  ],
  getDataTimePoints: [               // 爬取时间点
    '08:00', '08:15', '08:30', ...
  ],
  highPVTimePoints: [                // 高频爬取时间点
    '09:00', '09:15', '09:30', ...
  ],
  params: {
    formType: 'FR',                  // 表单类型（FR/EL）
    getDataType: 'dom',              // 获取方式（dom/api）
    dataItemCode: 'prov_ah_...',     // 数据项编码（用于状态查询）
    isSecondaryDisclosure: true,     // 是否二次披露（周末特殊处理）
    values: [
      { type: ['T-1', 'T', 'T+1'] }, // 日期循环
      { type: 'select', values: ['A', 'B'] }, // 下拉选项
      { type: 'queryBtn' }           // 查询按钮
    ]
  }
}
```

**配置设计优势**：
- **声明式配置**：无需编写爬取代码，只需配置参数
- **灵活扩展**：新增数据项仅需添加配置对象
- **时间控制**：精确到15分钟粒度的时间调度
- **日期计算**：支持相对日期（T、T-1、M、M-1）

---

### 7. Python 辅助服务

**文件位置**: `doc/Python/apiServer/`

#### 7.1 验证码识别服务

**接口**: `POST /captchaSolver`

**技术方案**：
- **OpenCV**：滑块验证码缺口识别
- **模板匹配**：计算滑块与背景图的匹配度
- **距离计算**：返回滑块需要移动的像素距离

**核心算法**：
```python
def generate_distance(sliding_b64, back_b64):
    # Base64 → 图片对象
    sliding_img = decode_image(sliding_b64)
    back_img = decode_image(back_b64)
    
    # 灰度化、边缘检测
    sliding_gray = cv2.cvtColor(sliding_img, cv2.COLOR_BGR2GRAY)
    back_gray = cv2.cvtColor(back_img, cv2.COLOR_BGR2GRAY)
    
    # 模板匹配
    result = cv2.matchTemplate(back_gray, sliding_gray, cv2.TM_CCOEFF_NORMED)
    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
    
    return {'distance': max_loc[0]}
```

#### 7.2 分片上传服务

**接口**: `POST /uploadChunks`

**应用场景**：大文件上传（避免单次传输超时）

**流程**：
1. 前端将文件切片（如每片 1MB）
2. 逐片上传到服务器临时目录
3. 全部上传完成后，服务器合并文件
4. 返回完整文件的 Base64 或路径

---

## 💎 核心技术难点分析

### 难点 1：异步流程编排与状态管理

**挑战**：
- 数据项之间有依赖关系（如：先选日期，再选分类，最后查询）
- 每个操作需等待DOM渲染完成
- 支持暂停/恢复/停止
- 异常情况需要重试或跳过

**解决方案**：
1. **AsyncQueue（异步队列）**：使用异步迭代器 `Symbol.asyncIterator`
2. **Promise 链式调用**：每个操作返回 Promise，保证执行顺序
3. **状态机模式**：LoopController 管理全局状态
4. **装饰器模式**：在关键操作前后插入校验、日志

**代码示例**：
```typescript
// 异步队列的异步迭代器实现
async *[Symbol.asyncIterator](): AsyncGenerator<T> {
  while (true) {
    if (this.queue.length === 0) {
      // 队列为空时，等待新数据加入
      await new Promise<void>((resolve) => (this.resolve = resolve));
    }
    yield this.queue.shift() as T;
  }
}
```

---

### 难点 2：DOM 动态渲染时机捕获

**挑战**：
- Vue/React 等框架的异步渲染
- 接口数据返回后才渲染元素
- 懒加载、虚拟滚动等优化技术
- 过早操作导致元素不存在

**解决方案**：
1. **MutationObserver**：监听 DOM 树变化
2. **轮询 + 超时**：最多等待 10 秒，避免死等
3. **多次重试**：第一次失败后，延迟 1.5 秒重试
4. **稳定性判断**：连续 100ms 无变化视为稳定

**关键代码**：
```typescript
// DomRenderWatcher.ts
watch(): Promise<void> {
  return new Promise((resolve) => {
    let timer: any
    const observer = new MutationObserver(() => {
      clearTimeout(timer)
      timer = setTimeout(() => {
        observer.disconnect()
        resolve()
      }, 100)  // 100ms 内无变化视为稳定
    })
    
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true
    })
    
    // 超时保护
    setTimeout(() => {
      observer.disconnect()
      resolve()
    }, 10000)
  })
}
```

---

### 难点 3：表格数据解析（合并单元格）

**挑战**：
- `rowspan` 和 `colspan` 导致行列不对齐
- 需要还原出完整的二维数组
- 空白单元格需要填充前序单元格的值

**算法设计**：
1. 计算表格最大列数（考虑 colspan）
2. 使用 `spanMap` 记录被占用的单元格位置
3. 遍历时跳过被占用的位置
4. 填充当前单元格的值

**时间复杂度**：O(rows × cols)

**空间复杂度**：O(rows × cols)（存储 spanMap）

---

### 难点 4：请求拦截与数据校验

**挑战**：
- Content Script 无法直接访问页面的 `window` 对象
- Manifest V3 不支持 `webRequest.onBeforeRequest`（仅 Declarative Net Request）
- 需要拦截 `fetch` 和 `XMLHttpRequest`

**技术方案**：
1. **Injected Script**：注入到页面上下文，重写全局 `fetch` 和 `XMLHttpRequest`
2. **CustomEvent 通信**：通过 `window.dispatchEvent` 发送数据
3. **Content Script 监听**：通过 `window.addEventListener` 接收
4. **多重校验**：URL、查询参数、日期范围

**安全性考虑**：
- 页面 JS 无法访问 Chrome Extension API（隔离性）
- 拦截的数据仅发送到 Content Script，不暴露给页面
- 校验不通过的数据会记录日志但不存储

---

### 难点 5：多省份、多模式构建配置

**挑战**：
- 4 个省份 × 3 种模式 = 12 种构建产物
- 每种构建有不同的：
  - URL 匹配规则
  - 扩展名称和图标
  - 环境变量（API 地址、单位 ID）
  - Content Script 注入规则

**解决方案**：
1. **动态 Manifest 生成**：根据 `mode` 参数生成不同的 manifest.json
2. **Vite 环境变量**：通过 `.env.*` 文件管理配置
3. **构建脚本**：npm scripts 定义 12 个构建命令
4. **配置中心化**：`config/systems.ts` 统一管理省份配置

**构建产物示例**：
```
dist/
├── devAnHui/          # 安徽开发环境
├── prodAnHui/         # 安徽生产自动
├── prodAnHuiH/        # 安徽生产手动
├── devBeiJing/        # 北京开发环境
└── ...
```

---

### 难点 6：数据去重与状态查询

**挑战**：
- 避免重复爬取已录入的数据
- 断点续传（中途中断后从未完成的日期继续）
- 多数据项并发查询

**解决方案**：
1. **接口查询**：调用后端接口，查询每个日期的录入状态
2. **状态码映射**：
   - `0` - 未录入
   - `1` - 已录入
   - `2` - 部分录入
3. **日期差异计算**：
   - 配置项：`['T-1', 'T', 'T+1']`
   - 接口返回：`T-1` 已录入，`T` 和 `T+1` 未录入
   - 实际爬取：仅爬取 `['T', 'T+1']`
4. **异步并发**：使用 `Promise.all` 并发查询多个数据项

**代码示例**：
```typescript
// 查询录入状态
const dataStatusList = await MsgFromToBackground
  .getInstance()
  .sendAsyncMsgToBackground({ 
    type: 'checkStatus', 
    payload: paramsList 
  })

// 过滤未录入的日期
const unEnteredDateList = dataStatusList
  .filter(item => item.status === 0)
  .map(item => calculateDateDiff(item.date))  // ['T', 'T+1']
```

---

## 📊 性能优化策略

### 1. 并发控制
- **AsyncQueue**：队列化处理，避免同时发起过多请求
- **并发限制**：最多同时爬取 1 个数据项（避免页面卡死）

### 2. 请求优化
- **状态查询批量化**：一次查询多个数据项的状态
- **心跳间隔**：Content ↔ Background 每 30 秒一次心跳

### 3. 内存优化
- **及时清理**：每次爬取完成后清理 `interceptInfoSessionKey`
- **事件解绑**：`EventBinder` 统一管理事件监听器的绑定和解绑

### 4. 用户体验
- **进度反馈**：在控制台输出当前爬取进度
- **错误提示**：异常情况记录到 LogDB，用户可查看
- **手动控制**：Popup 面板支持暂停/恢复/停止

---

## 🔒 安全与稳定性

### 1. 异常处理
- **Try-Catch 包裹**：所有异步操作均有异常捕获
- **Promise.reject**：明确的错误传递
- **日志记录**：错误信息记录到 LogDB（IndexedDB）

### 2. 数据校验
- **URL 校验**：确保拦截的是目标请求
- **参数校验**：对比查询参数与预期值
- **日期范围校验**：避免爬取超出范围的数据

### 3. 超时保护
- **DOM 监听超时**：最多等待 10 秒
- **消息响应超时**：Background 最多等待 30 秒
- **请求超时**：fetch 自带超时机制

### 4. 降级策略
- **重试机制**：DOM 元素未找到时最多重试 2 次
- **跳过机制**：某数据项失败时，跳过并继续下一项
- **手动兜底**：生产手动模式（prodH）供人工介入

---

## 📈 可扩展性设计

### 1. 新增省份
1. 在 `config/systems.ts` 添加省份配置
2. 在 `src/entries/contentScript/informationDisclosure/dataInfoConfig/` 新建省份目录
3. 编写数据项配置文件
4. 在 `package.json` 添加构建脚本

### 2. 新增数据项
1. 在对应省份配置文件中添加数据项对象
2. 配置菜单层级、爬取时间点、循环参数
3. 无需修改核心代码

### 3. 新增操作类型
1. 在 `autoClick/` 目录下新建操作类（如 `SetXxx.ts`）
2. 继承 `Provinces` 基类
3. 实现 `start()` 方法
4. 在 `SetDynamicLoop.ts` 中注册新类型

---

## 🎓 技术亮点总结

### 1. **架构设计**
- ✅ Manifest V3 现代化扩展架构
- ✅ 单例模式、工厂模式、观察者模式
- ✅ 消息总线架构（Popup ↔ Background ↔ Content）

### 2. **自动化技术**
- ✅ RPA 流程自动化（菜单点击、表单填写、数据抓取）
- ✅ 异步队列 + 异步迭代器
- ✅ DOM 渲染监听（MutationObserver）

### 3. **数据处理**
- ✅ 请求拦截（重写 fetch/XHR）
- ✅ 表格解析（合并单元格算法）
- ✅ 数据去重（状态查询 + 日期差异计算）

### 4. **工程化**
- ✅ TypeScript 类型安全
- ✅ Vite 多环境构建
- ✅ 12 种构建配置管理
- ✅ 模块化配置系统

### 5. **稳定性**
- ✅ 多重异常处理
- ✅ 重试与超时机制
- ✅ 日志系统（IndexedDB）
- ✅ 暂停/恢复/停止控制

---

## 📚 关键文件索引

| 功能模块 | 核心文件 | 说明 |
|---------|---------|------|
| **入口配置** | `src/manifest.ts` | 动态 Manifest 生成 |
| **构建配置** | `vite.config.ts` | Vite 多环境构建 |
| **省份系统** | `config/systems.ts` | 省份 URL 配置 |
| **数据配置** | `dataInfoConfig/*/index.ts` | 各省数据项配置 |
| **动作控制** | `autoClick/ActionEntrance.ts` | 任务调度入口 |
| **循环控制** | `autoClick/LoopController.ts` | 状态管理 |
| **动态循环** | `autoClick/SetDynamicLoop.ts` | 操作序列编排 |
| **DOM监听** | `utils/DomRenderWatcher.ts` | 渲染监听 |
| **请求拦截** | `autoClick/InterceptRequest.ts` | 数据拦截 |
| **表格解析** | `autoClick/TableParser.ts` | 表格解析 |
| **树形菜单** | `autoClick/SetTreeRecursively.ts` | 菜单递归点击 |
| **消息通信** | `utils/Messenger.ts` | 消息桥接 |
| **异步队列** | `utils/AsyncQueue.ts` | 队列管理 |
| **后端服务** | `doc/Python/apiServer/api/start.py` | Flask API |

---

## 🚀 未来优化方向

1. **智能化**：
   - 基于机器学习的异常检测
   - 自适应延迟时间调整
   - 验证码识别准确率优化

2. **可视化**：
   - 实时爬取进度仪表盘
   - 数据完整性统计图表
   - 错误日志分析面板

3. **性能**：
   - WebWorker 并发处理
   - 数据压缩传输
   - 增量式数据同步

4. **扩展性**：
   - 插件化架构（热插拔省份配置）
   - 低代码配置平台
   - 可视化流程编排器

---

**文档版本**: v1.0  
**最后更新**: 2025年11月  
**维护者**: 技术团队


