# 系统架构图解

本文档使用 **Mermaid** 图表语言可视化展示系统的各个架构层次和交互流程。

---

## 1. 整体架构图

```mermaid
graph TB
    subgraph "Chrome Extension"
        A[Popup<br/>控制面板] --> B[Background<br/>Service Worker]
        C[Options<br/>配置页] --> B
        D[Content Script<br/>核心业务逻辑] --> B
        E[Injected Script<br/>请求拦截] -.CustomEvent.-> D
    end
    
    subgraph "Target Web Application"
        F[电力交易平台<br/>Vue/React SPA]
        F --> E
        D --> F
    end
    
    B --> G[Python API Server<br/>验证码识别]
    B --> H[Data Storage<br/>大数据平台]
    
    style A fill:#e1f5ff
    style B fill:#ffe1e1
    style D fill:#e1ffe1
    style E fill:#fff9e1
    style F fill:#f0f0f0
    style G fill:#ffe1f5
    style H fill:#e1e1ff
```

---

## 2. Chrome Extension 内部架构

```mermaid
graph LR
    subgraph "Popup UI"
        A1[开始按钮]
        A2[暂停按钮]
        A3[停止按钮]
        A4[状态显示]
    end
    
    subgraph "Background Service Worker"
        B1[消息路由<br/>MsgFromToContent]
        B2[消息处理<br/>BackgroundMsgHandler]
        B3[数据存储<br/>SaveToHD]
        B4[状态查询<br/>CheckStatus]
        B5[日志管理<br/>LogDB]
    end
    
    subgraph "Content Script"
        C1[动作入口<br/>ActionEntrance]
        C2[循环控制<br/>LoopController]
        C3[动态循环<br/>SetDynamicLoop]
        C4[DOM监听<br/>DomRenderWatcher]
        C5[请求拦截<br/>InterceptRequest]
        C6[表格解析<br/>TableParser]
    end
    
    A1 --> B1
    A2 --> B1
    A3 --> B1
    B1 --> B2
    B2 --> B3
    B2 --> B4
    B2 --> B5
    
    B1 <--> C1
    C1 --> C2
    C1 --> C3
    C3 --> C4
    C3 --> C5
    C3 --> C6
    
    style A1 fill:#90EE90
    style A2 fill:#FFD700
    style A3 fill:#FF6347
    style B1 fill:#87CEEB
    style C1 fill:#DDA0DD
```

---

## 3. 数据流向图

```mermaid
sequenceDiagram
    participant U as 用户
    participant P as Popup
    participant B as Background
    participant C as Content Script
    participant I as Injected Script
    participant W as Web Page
    participant API as Python API
    participant DB as 数据平台
    
    U->>P: 点击"开始"按钮
    P->>B: 发送启动消息
    B->>C: 转发消息
    
    C->>C: 加载数据项配置
    C->>B: 查询数据录入状态
    B->>DB: HTTP 请求状态接口
    DB-->>B: 返回状态列表
    B-->>C: 返回状态
    
    C->>C: 过滤未录入数据项
    C->>C: 加入异步队列
    
    loop 遍历数据队列
        C->>W: 点击菜单
        W-->>C: DOM 变化
        C->>C: DomRenderWatcher 监听
        
        C->>W: 填写表单
        C->>W: 点击查询
        
        W->>I: 发起 fetch 请求
        I->>W: 拦截响应
        I->>C: CustomEvent 发送数据
        
        C->>C: 校验数据
        C->>B: 发送数据
        B->>DB: 存储数据
        DB-->>B: 确认
    end
    
    C->>P: 完成通知
    P->>U: 显示完成状态
```

---

## 4. 状态机图（LoopController）

```mermaid
stateDiagram-v2
    [*] --> Running: start()
    
    Running --> Paused: pause()
    Running --> Stopped: stop()
    
    Paused --> Running: resume()
    Paused --> Stopped: stop()
    
    Stopped --> Running: reset()
    Stopped --> [*]
    
    Running: 正在运行<br/>isRunning=true<br/>isStopped=false
    Paused: 已暂停<br/>isRunning=false<br/>isStopped=false
    Stopped: 已停止<br/>isRunning=false<br/>isStopped=true
```

---

## 5. 任务调度流程图

```mermaid
flowchart TD
    Start([开始]) --> GetTime[获取当前时间点<br/>如: 08:15]
    GetTime --> LoadConfig[加载数据项配置]
    
    LoadConfig --> CheckStatus{是否开启<br/>状态查询?}
    
    CheckStatus -->|是| QueryStatus[调用接口查询<br/>数据录入状态]
    CheckStatus -->|否| FilterByTime[按时间点过滤]
    
    QueryStatus --> CalcDate[计算日期差异<br/>生成待爬取日期列表]
    CalcDate --> FilterByTime
    
    FilterByTime --> IsEmpty{队列是否为空?}
    
    IsEmpty -->|是| WaitNext[等待下次触发]
    IsEmpty -->|否| EnQueue[加入异步队列]
    
    EnQueue --> LoopStart[开始循环]
    
    LoopStart --> CheckPause{检查是否暂停?}
    CheckPause -->|是| WaitResume[等待恢复]
    WaitResume --> CheckPause
    CheckPause -->|否| CheckStop{检查是否停止?}
    
    CheckStop -->|是| End([结束])
    CheckStop -->|否| DeQueue[取出数据项]
    
    DeQueue --> ClickMenu[点击菜单]
    ClickMenu --> WaitDOM1[等待DOM渲染]
    WaitDOM1 --> FillForm[填写表单]
    FillForm --> ClickQuery[点击查询]
    ClickQuery --> WaitData[等待数据返回]
    WaitData --> ParseData[解析数据]
    ParseData --> SaveData[存储数据]
    
    SaveData --> IsLast{是否最后一项?}
    IsLast -->|否| LoopStart
    IsLast -->|是| SetTimer[设置下次启动定时器]
    
    SetTimer --> End
    WaitNext --> End
    
    style Start fill:#90EE90
    style End fill:#FF6347
    style CheckStatus fill:#FFD700
    style CheckPause fill:#FFD700
    style CheckStop fill:#FFD700
    style IsEmpty fill:#FFD700
    style IsLast fill:#FFD700
```

---

## 6. DOM 渲染监听机制

```mermaid
flowchart TD
    Start([开始监听]) --> CreateObserver[创建 MutationObserver]
    
    CreateObserver --> SetConfig[配置监听选项<br/>childList: true<br/>subtree: true<br/>attributes: true]
    
    SetConfig --> StartObserve[开始观察 document.body]
    
    StartObserve --> WaitMutation[等待 DOM 变化]
    
    WaitMutation --> OnMutation{DOM 变化事件}
    
    OnMutation --> ResetTimer[重置稳定性计时器]
    ResetTimer --> StartTimer[启动 100ms 计时]
    StartTimer --> WaitMutation
    
    StartTimer --> CheckStable{100ms 内<br/>无新变化?}
    CheckStable -->|否| WaitMutation
    CheckStable -->|是| Disconnect[断开观察器]
    
    Disconnect --> Resolve[Promise.resolve]
    Resolve --> End([结束监听])
    
    StartObserve --> SetTimeout[设置 10s 超时]
    SetTimeout --> TimeoutCheck{超时?}
    TimeoutCheck -->|是| Disconnect
    TimeoutCheck -->|否| WaitMutation
    
    style Start fill:#90EE90
    style End fill:#87CEEB
    style OnMutation fill:#FFD700
    style CheckStable fill:#FFD700
    style TimeoutCheck fill:#FF6347
```

---

## 7. 请求拦截架构

```mermaid
graph TB
    subgraph "Page Context (Main World)"
        A[原始 window.fetch]
        B[原始 XMLHttpRequest]
        C[Injected Script<br/>injected.js]
        D[重写后的 fetch]
        E[重写后的 XHR]
    end
    
    subgraph "Content Script (Isolated World)"
        F[InterceptRequest]
        G[监听 CustomEvent]
        H[校验数据]
        I[发送到 Background]
    end
    
    subgraph "Background Service Worker"
        J[接收数据]
        K[调用存储接口]
    end
    
    C --> D
    C --> E
    D -.克隆响应.-> A
    E -.克隆响应.-> B
    
    D --CustomEvent--> F
    E --CustomEvent--> F
    
    F --> G
    G --> H
    H --> I
    
    I --chrome.runtime--> J
    J --> K
    
    style C fill:#FFE4B5
    style D fill:#FFB6C1
    style E fill:#FFB6C1
    style F fill:#98FB98
    style J fill:#87CEEB
```

---

## 8. 表格解析算法

```mermaid
flowchart TD
    Start([开始解析表格]) --> GetTable[获取 table 元素]
    
    GetTable --> CalcCols[计算总列数<br/>遍历所有行<br/>累加 colspan]
    
    CalcCols --> InitData[初始化 data 数组]
    
    InitData --> LoopRows{遍历行}
    
    LoopRows --> InitRow[初始化当前行<br/>填充 null]
    InitRow --> SetPointer[设置列指针 = 0]
    
    SetPointer --> LoopCells{遍历单元格}
    
    LoopCells --> CheckMerged{当前位置<br/>被占用?}
    CheckMerged -->|是| IncPointer[列指针++]
    IncPointer --> CheckMerged
    
    CheckMerged -->|否| GetSpan[获取 rowspan<br/>和 colspan]
    GetSpan --> FillValue[填充单元格值]
    FillValue --> MarkSpan[标记被占用的位置<br/>更新 spanMap]
    MarkSpan --> MovePointer[列指针 += colspan]
    
    MovePointer --> LoopCells
    
    LoopCells -->|结束| PushRow[添加行到 data]
    PushRow --> LoopRows
    
    LoopRows -->|结束| Return[返回 data 二维数组]
    Return --> End([结束])
    
    style Start fill:#90EE90
    style End fill:#87CEEB
    style CheckMerged fill:#FFD700
```

**spanMap 示例**:
```
表格:
┌───┬───┬───┐
│ A │   B   │  (B colspan=2)
│   ├───┬───┤  (A rowspan=2)
│   │ C │ D │
└───┴───┴───┘

spanMap:
{
  '0,2': true,  // 第1行第3列被B占用
  '1,0': true,  // 第2行第1列被A占用
  '1,2': true   // (示例，实际取决于具体情况)
}

解析结果:
[
  ['A', 'B', 'B'],
  ['A', 'C', 'D']
]
```

---

## 9. 多省份构建配置

```mermaid
graph TB
    subgraph "构建命令"
        A[npm run devAH]
        B[npm run prodAH]
        C[npm run prodAHH]
        D[npm run devBJ]
        E[npm run prodBJ]
        F["... (共12个命令)"]
    end
    
    subgraph "Vite 构建流程"
        G[解析 mode 参数<br/>如: devAnHui]
        H[调用 getManifest(mode)]
        I[生成 manifest.json]
        J[替换环境变量]
        K[选择图标目录<br/>iconsDev/iconsProd]
        L[打包输出<br/>dist/devAnHui/]
    end
    
    subgraph "配置文件"
        M[config/systems.ts<br/>省份URL配置]
        N[dataInfoConfig/AnHui/<br/>数据项配置]
        O[.env.devAnHui<br/>环境变量]
    end
    
    A --> G
    B --> G
    C --> G
    D --> G
    E --> G
    F --> G
    
    G --> H
    H --> M
    H --> N
    H --> O
    
    H --> I
    H --> J
    H --> K
    
    I --> L
    J --> L
    K --> L
    
    style A fill:#90EE90
    style B fill:#FFD700
    style C fill:#FF6347
    style L fill:#87CEEB
```

---

## 10. 数据配置层次结构

```mermaid
graph TD
    A[dataInfoConfig/index.ts<br/>统一导出] --> B{根据当前省份}
    
    B --> C[AnHui/index.ts]
    B --> D[BeiJing/index.ts]
    B --> E[ShanDong/index.ts]
    B --> F[JiangSu/index.ts]
    
    C --> C1[snxhShiChangYunXing.ts<br/>市场运行]
    C --> C2[snxhShiChangJieSuan.ts<br/>市场结算]
    C --> C3[snxhShiChangYuCe.ts<br/>市场预测]
    C --> C4[tabs.ts<br/>标签页配置]
    
    C1 --> G1["数据项1<br/>{code, tab, menuLevels, params}"]
    C1 --> G2["数据项2"]
    C1 --> G3["数据项3"]
    
    G1 --> H1[menuLevels: 菜单层级]
    G1 --> H2[getDataTimePoints: 时间点]
    G1 --> H3[params.values: 循环参数]
    
    H3 --> I1["日期循环<br/>{type: ['T-1', 'T', 'T+1']}"]
    H3 --> I2["下拉选择<br/>{type: 'select', values: [...]}"]
    H3 --> I3["查询按钮<br/>{type: 'queryBtn'}"]
    
    style A fill:#FFE4B5
    style C fill:#98FB98
    style G1 fill:#87CEEB
```

---

## 11. 异步队列工作原理

```mermaid
sequenceDiagram
    participant P as Producer<br/>(生产者)
    participant Q as AsyncQueue<br/>(队列)
    participant C as Consumer<br/>(消费者)
    
    Note over Q: 队列初始为空
    
    C->>Q: for await (item of queue)
    Note over C: 进入等待状态
    
    P->>Q: enqueue(item1)
    Note over Q: queue = [item1]<br/>唤醒消费者
    
    Q->>C: yield item1
    C->>C: 处理 item1
    
    C->>Q: 继续迭代
    Note over C: 队列为空，等待
    
    P->>Q: enqueue(item2)
    P->>Q: enqueue(item3)
    Note over Q: queue = [item2, item3]<br/>唤醒消费者
    
    Q->>C: yield item2
    C->>C: 处理 item2
    
    C->>Q: 继续迭代
    Q->>C: yield item3
    C->>C: 处理 item3
    
    C->>Q: 继续迭代
    Note over C: 队列为空，等待
    
    Note over P: 后续可继续添加
```

**关键代码**:
```typescript
async *[Symbol.asyncIterator](): AsyncGenerator<T> {
  while (true) {
    if (this.queue.length === 0) {
      // 队列为空，创建 Promise 等待
      await new Promise<void>((resolve) => {
        this.resolve = resolve
      })
    }
    // 取出队首元素
    yield this.queue.shift() as T
  }
}
```

---

## 12. 消息通信架构

```mermaid
graph TB
    subgraph "Popup"
        A1[按钮点击]
    end
    
    subgraph "Content Script"
        B1[MsgFromToBackground<br/>消息发送器]
        B2[ContentMsgHandler<br/>消息处理器]
    end
    
    subgraph "Background Service Worker"
        C1[MsgFromToContent<br/>消息路由]
        C2[BackgroundMsgHandler<br/>消息处理器]
        C3[SaveToHD<br/>数据存储]
        C4[CheckStatus<br/>状态查询]
    end
    
    subgraph "Backend API"
        D1[Python Flask Server]
        D2[Data Platform API]
    end
    
    A1 --chrome.runtime.sendMessage--> C1
    
    B1 --chrome.runtime.Port--> C1
    C1 --> C2
    
    C2 --> C3
    C2 --> C4
    
    C3 --> D2
    C4 --> D2
    
    C1 --回传消息--> B2
    
    style A1 fill:#90EE90
    style B1 fill:#FFB6C1
    style C1 fill:#87CEEB
    style C2 fill:#DDA0DD
    style D1 fill:#F0E68C
```

**消息类型**:
- `saveDataInfo`: 保存数据
- `checkStatus`: 查询录入状态
- `contentReady`: Content Script 准备就绪
- `memoryRecord`: 记录内存日志
- `queryValueWrong`: 查询参数错误

---

## 13. 性能优化策略

```mermaid
mindmap
  root((性能优化))
    并发控制
      AsyncQueue 队列化
      单数据项串行处理
      避免页面卡死
    
    请求优化
      状态查询批量化
      Promise.all 并发
      心跳间隔 30s
    
    内存优化
      及时清理 Storage
      事件解绑 EventBinder
      DOM 引用释放
    
    渲染优化
      MutationObserver 零轮询
      稳定性判断 100ms
      超时保护 10s
    
    数据优化
      去重减少 60% 爬取
      增量式同步
      数据压缩传输
```

---

## 14. 错误处理流程

```mermaid
flowchart TD
    Start([操作开始]) --> TryCatch{Try-Catch 包裹}
    
    TryCatch -->|成功| Success[返回结果]
    TryCatch -->|异常| LogError[记录错误日志<br/>LogDB.addLog]
    
    LogError --> Retry{是否可重试?}
    
    Retry -->|是| CheckRetryCount{重试次数<br/>< 最大值?}
    CheckRetryCount -->|是| Delay[延迟 1.5s]
    Delay --> TryCatch
    CheckRetryCount -->|否| MarkFailed[标记失败]
    
    Retry -->|否| SkipItem{是否跳过<br/>并继续?}
    
    SkipItem -->|是| NextItem[继续下一项]
    SkipItem -->|否| StopAll[停止所有任务]
    
    MarkFailed --> Manual{是否需要<br/>人工介入?}
    Manual -->|是| NotifyUser[通知用户]
    Manual -->|否| NextItem
    
    Success --> End([结束])
    NextItem --> End
    StopAll --> End
    NotifyUser --> End
    
    style Start fill:#90EE90
    style Success fill:#87CEEB
    style LogError fill:#FFD700
    style StopAll fill:#FF6347
```

---

## 15. 部署与运行流程

```mermaid
flowchart LR
    subgraph "开发阶段"
        A1[编写代码]
        A2[本地调试<br/>npm run watchDev]
        A3[修复 Bug]
    end
    
    subgraph "构建阶段"
        B1[选择目标省份<br/>如: AnHui]
        B2[选择运行模式<br/>dev/prod/prodH]
        B3[执行构建命令<br/>npm run prodAH]
        B4[生成产物<br/>dist/prodAnHui/]
    end
    
    subgraph "部署阶段"
        C1[打开 Chrome<br/>扩展管理页]
        C2[加载已解压的扩展]
        C3[选择 dist 目录]
        C4[扩展安装成功]
    end
    
    subgraph "运行阶段"
        D1[访问目标网站]
        D2[点击扩展图标]
        D3[点击开始按钮]
        D4[自动爬取数据]
        D5[查看日志]
    end
    
    A1 --> A2
    A2 --> A3
    A3 --> A1
    
    A2 --> B1
    B1 --> B2
    B2 --> B3
    B3 --> B4
    
    B4 --> C1
    C1 --> C2
    C2 --> C3
    C3 --> C4
    
    C4 --> D1
    D1 --> D2
    D2 --> D3
    D3 --> D4
    D4 --> D5
    
    style A2 fill:#90EE90
    style B3 fill:#FFD700
    style C4 fill:#87CEEB
    style D4 fill:#98FB98
```

---

## 16. 技术栈全景图

```mermaid
mindmap
  root((技术栈))
    前端核心
      TypeScript 5.2+
      Vue 3.3+
      Vite 5.0
      Element Plus
    
    浏览器扩展
      Chrome Extension
      Manifest V3
      Background Service Worker
      Content Script
      Injected Script
    
    工具库
      Lodash
      Day.js
      crypto-js
      node-html-parser
    
    后端辅助
      Python 3.9
      Flask
      OpenCV
      ddddocr
    
    高级特性
      MutationObserver
      CustomEvent
      异步迭代器 ES2018
      Proxy
    
    设计模式
      单例模式
      工厂模式
      观察者模式
      状态机模式
```

---

## 总结

以上 16 张图表从不同维度展示了系统的架构设计：

1. **整体架构** - 宏观视角
2. **内部架构** - 模块划分
3. **数据流向** - 交互时序
4. **状态机** - 状态转换
5. **任务调度** - 流程控制
6. **DOM监听** - 渲染捕获
7. **请求拦截** - 数据获取
8. **表格解析** - 算法实现
9. **构建配置** - 工程化
10. **配置层次** - 模块组织
11. **异步队列** - 并发控制
12. **消息通信** - 组件通信
13. **性能优化** - 优化策略
14. **错误处理** - 异常处理
15. **部署运行** - 完整流程
16. **技术栈** - 全景总览

这些图表可以直接在支持 Mermaid 的 Markdown 编辑器中渲染（如 Typora、VS Code、GitHub），也可以导出为 PNG/SVG 用于文档和演示。

---

**文档版本**: v1.0  
**最后更新**: 2025年11月  
**适用工具**: Typora、VS Code、GitHub、GitLab、Obsidian


